using System;
using System.Collections.Generic;
using Lumora.Core.Math;
using Lumora.Core.Components.Meshes;
using Lumora.Core.Phos;
using Lumora.Core.Logging;

namespace Lumora.Core.HelioUI.Rendering;

/// <summary>
/// Froox-style UI mesh generator. Builds a batched quad mesh for Helio UI elements.
/// Panels, images, and text are drawn as colored quads.
/// Text uses an optimized 8x12 bitmap font with run-length merging for efficiency.
/// </summary>
public class HelioUIMesh : ProceduralMesh
{
	public readonly Sync<float2> CanvasSize;
	public readonly Sync<float> PixelScale;
	public readonly Sync<color> BackgroundColor;

	private HelioCanvas _canvas;
	private Slot _rendererSlot;

	public HelioUIMesh()
	{
		CanvasSize = new Sync<float2>(this, new float2(400f, 600f));
		PixelScale = new Sync<float>(this, 100f);
		BackgroundColor = new Sync<color>(this, new color(0.1f, 0.1f, 0.12f, 0.95f));
	}

	public void SetCanvas(HelioCanvas canvas)
	{
		_canvas = canvas;
	}

	public void SetRendererSlot(Slot rendererSlot)
	{
		_rendererSlot = rendererSlot;
	}

	public override void OnAwake()
	{
		base.OnAwake();
		SubscribeToChanges(CanvasSize);
		SubscribeToChanges(PixelScale);
		SubscribeToChanges(BackgroundColor);
	}

	protected override void PrepareAssetUpdateData()
	{
	}

	protected override void UpdateMeshData(PhosMesh mesh)
	{
		mesh.Clear();

		if (_canvas == null || _canvas.Slot == null)
			return;

		var refSize = CanvasSize.Value;
		float pixelScale = PixelScale.Value <= 0.0001f ? 100f : PixelScale.Value;

		var submesh = new PhosTriangleSubmesh(mesh);
		mesh.Submeshes.Add(submesh);

		float z = 0f;

		// Base background quad (full canvas)
		AddQuad(submesh,
			new HelioRect(float2.Zero, refSize),
			BackgroundColor.Value,
			ref z,
			refSize,
			pixelScale);

		TraverseSlot(_canvas.Slot, submesh, ref z, refSize, pixelScale);

		uploadHint[MeshUploadHint.Flag.Geometry] = true;
		uploadHint[MeshUploadHint.Flag.Colors] = true;
	}

	private void TraverseSlot(Slot slot, PhosTriangleSubmesh submesh, ref float z, float2 refSize, float pixelScale)
	{
		if (slot == null || slot.ActiveSelf.Value == false)
			return;

		if (_rendererSlot != null && slot == _rendererSlot)
			return;

		var rect = slot.GetComponent<HelioRectTransform>();
		if (rect != null)
		{
			var computedRect = rect.Rect;

			var panel = slot.GetComponent<HelioPanel>();
			if (panel != null)
			{
				AddQuad(submesh, computedRect, panel.BackgroundColor.Value, ref z, refSize, pixelScale);
			}

			var image = slot.GetComponent<HelioImage>();
			if (image != null)
			{
				AddQuad(submesh, computedRect, image.Tint.Value, ref z, refSize, pixelScale);
			}

			var text = slot.GetComponent<HelioText>();
			if (text != null)
			{
				AddText(submesh, computedRect, text, ref z, refSize, pixelScale);
			}
		}

		foreach (var child in slot.Children)
		{
			TraverseSlot(child, submesh, ref z, refSize, pixelScale);
		}
	}

	// Z increment per quad - very small to keep UI essentially flat
	// Even with 10000 quads, total depth is only 0.01 world units
	private const float Z_INCREMENT = 0.000001f;

	private void AddQuad(PhosTriangleSubmesh submesh, HelioRect rect, color quadColor, ref float z, float2 refSize, float pixelScale)
	{
		// Skip invalid rects
		if (rect.Size.x <= 0 || rect.Size.y <= 0)
			return;

		var quad = new PhosQuad(submesh)
		{
			UseColors = true
		};

		float2 sizeWorld = rect.Size / pixelScale;
		float2 center = rect.Min + rect.Size * 0.5f;
		float2 worldCenter2D = (center - refSize * 0.5f) / pixelScale;

		quad.Size = sizeWorld;
		quad.Position = new float3(worldCenter2D.x, worldCenter2D.y, z);
		quad.Color = quadColor;
		quad.Update();

		z += Z_INCREMENT;
	}

	private void AddText(PhosTriangleSubmesh submesh, HelioRect rect, HelioText text, ref float z, float2 refSize, float pixelScale)
	{
		if (string.IsNullOrEmpty(text.Content.Value))
			return;

		float fontSize = MathF.Max(8f, text.FontSize.Value);
		float lineHeight = fontSize * text.LineHeight.Value;
		float charWidth = fontSize * ((float)FONT_WIDTH / FONT_HEIGHT);
		float charSpacing = charWidth * 0.15f; // 15% spacing between characters
		float maxWidth = rect.Size.x;

		// Build lines with word wrapping
		var lines = BuildLines(text.Content.Value, charWidth + charSpacing, maxWidth, text.Overflow.Value);

		// Start from top of rect
		float yCursor = rect.Max.y - fontSize;

		foreach (var line in lines)
		{
			if (yCursor + fontSize < rect.Min.y)
				break;

			float lineWidth = line.Length * (charWidth + charSpacing);
			float xStart = rect.Min.x;

			if (text.Alignment.Value == TextAlignment.Center)
				xStart = rect.Min.x + (rect.Size.x - lineWidth) * 0.5f;
			else if (text.Alignment.Value == TextAlignment.Right)
				xStart = rect.Max.x - lineWidth;

			float xCursor = xStart;

			foreach (char c in line)
			{
				if (TryGetGlyph(c, out var glyph))
				{
					RenderGlyph(submesh, glyph, xCursor, yCursor, fontSize, text.Color.Value, ref z, refSize, pixelScale);
				}
				xCursor += charWidth + charSpacing;
			}

			yCursor -= lineHeight;
		}
	}

	private List<string> BuildLines(string content, float charAdvance, float maxWidth, TextOverflow overflow)
	{
		var lines = new List<string>();
		var currentLine = "";

		foreach (char c in content)
		{
			if (c == '\n')
			{
				lines.Add(currentLine);
				currentLine = "";
				continue;
			}

			if (overflow == TextOverflow.Wrap)
			{
				float nextWidth = (currentLine.Length + 1) * charAdvance;
				if (nextWidth > maxWidth && currentLine.Length > 0)
				{
					// Try word wrap - find last space
					int lastSpace = currentLine.LastIndexOf(' ');
					if (lastSpace > 0 && c != ' ')
					{
						lines.Add(currentLine.Substring(0, lastSpace));
						currentLine = currentLine.Substring(lastSpace + 1) + c;
					}
					else
					{
						lines.Add(currentLine);
						currentLine = c.ToString();
					}
					continue;
				}
			}

			currentLine += c;
		}

		if (currentLine.Length > 0)
			lines.Add(currentLine);

		return lines;
	}

	/// <summary>
	/// Render a glyph using run-length optimized quads.
	/// Instead of one quad per pixel, we merge horizontal runs into single quads.
	/// </summary>
	private void RenderGlyph(PhosTriangleSubmesh submesh, byte[] glyph, float x, float y, float fontSize, color glyphColor, ref float z, float2 refSize, float pixelScale)
	{
		float pixelSize = fontSize / FONT_HEIGHT;

		for (int row = 0; row < FONT_HEIGHT; row++)
		{
			byte rowData = glyph[row];
			if (rowData == 0) continue; // Skip empty rows

			int col = 0;
			while (col < FONT_WIDTH)
			{
				// Find start of a run
				if ((rowData & (1 << (FONT_WIDTH - 1 - col))) == 0)
				{
					col++;
					continue;
				}

				// Found a pixel, now find the run length
				int runStart = col;
				while (col < FONT_WIDTH && (rowData & (1 << (FONT_WIDTH - 1 - col))) != 0)
				{
					col++;
				}
				int runLength = col - runStart;

				// Create a single quad for this run
				float px = x + runStart * pixelSize;
				float py = y - row * pixelSize;
				float pw = runLength * pixelSize;
				float ph = pixelSize;

				var glyphRect = new HelioRect(new float2(px, py - ph), new float2(pw, ph));
				AddQuad(submesh, glyphRect, glyphColor, ref z, refSize, pixelScale);
			}
		}
	}

	// ===== Font Data - 8x12 bitmap font stored as bytes (1 bit per pixel) =====
	private const int FONT_WIDTH = 8;
	private const int FONT_HEIGHT = 12;

	private static readonly Dictionary<char, byte[]> GlyphData = BuildGlyphData();

	private static bool TryGetGlyph(char c, out byte[] glyph)
	{
		// Try exact match first
		if (GlyphData.TryGetValue(c, out glyph))
			return true;

		// Try uppercase
		if (GlyphData.TryGetValue(char.ToUpperInvariant(c), out glyph))
			return true;

		// Return space for unknown characters
		glyph = GlyphData.GetValueOrDefault(' ', new byte[FONT_HEIGHT]);
		return true;
	}

	/// <summary>
	/// Build glyph data. Each glyph is 8x12 pixels stored as 12 bytes (1 byte per row).
	/// Bit 7 (MSB) is leftmost pixel, bit 0 is rightmost.
	/// </summary>
	private static Dictionary<char, byte[]> BuildGlyphData()
	{
		var d = new Dictionary<char, byte[]>();

		// Uppercase letters - clean, readable 8x12 design
		d['A'] = new byte[] { 0x00, 0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00 };
		d['B'] = new byte[] { 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00 };
		d['C'] = new byte[] { 0x00, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00, 0x00 };
		d['D'] = new byte[] { 0x00, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00, 0x00 };
		d['E'] = new byte[] { 0x00, 0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00 };
		d['F'] = new byte[] { 0x00, 0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00 };
		d['G'] = new byte[] { 0x00, 0x3C, 0x66, 0x60, 0x60, 0x6E, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00 };
		d['H'] = new byte[] { 0x00, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00 };
		d['I'] = new byte[] { 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00 };
		d['J'] = new byte[] { 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x6C, 0x38, 0x00, 0x00 };
		d['K'] = new byte[] { 0x00, 0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x00, 0x00 };
		d['L'] = new byte[] { 0x00, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00 };
		d['M'] = new byte[] { 0x00, 0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00 };
		d['N'] = new byte[] { 0x00, 0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00 };
		d['O'] = new byte[] { 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00 };
		d['P'] = new byte[] { 0x00, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00 };
		d['Q'] = new byte[] { 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6E, 0x3C, 0x0E, 0x00, 0x00 };
		d['R'] = new byte[] { 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x00, 0x00 };
		d['S'] = new byte[] { 0x00, 0x3C, 0x66, 0x60, 0x3C, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00, 0x00 };
		d['T'] = new byte[] { 0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00 };
		d['U'] = new byte[] { 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00 };
		d['V'] = new byte[] { 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x3C, 0x18, 0x00, 0x00 };
		d['W'] = new byte[] { 0x00, 0x63, 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x63, 0x00, 0x00 };
		d['X'] = new byte[] { 0x00, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x00, 0x00 };
		d['Y'] = new byte[] { 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00 };
		d['Z'] = new byte[] { 0x00, 0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00 };

		// Lowercase letters
		d['a'] = new byte[] { 0x00, 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00 };
		d['b'] = new byte[] { 0x00, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00 };
		d['c'] = new byte[] { 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00, 0x00 };
		d['d'] = new byte[] { 0x00, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00 };
		d['e'] = new byte[] { 0x00, 0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x60, 0x66, 0x3C, 0x00, 0x00 };
		d['f'] = new byte[] { 0x00, 0x1C, 0x36, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00 };
		d['g'] = new byte[] { 0x00, 0x00, 0x00, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00 };
		d['h'] = new byte[] { 0x00, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00 };
		d['i'] = new byte[] { 0x00, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00 };
		d['j'] = new byte[] { 0x00, 0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x6C, 0x38, 0x00 };
		d['k'] = new byte[] { 0x00, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x66, 0x00, 0x00 };
		d['l'] = new byte[] { 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00 };
		d['m'] = new byte[] { 0x00, 0x00, 0x00, 0x76, 0x7F, 0x6B, 0x6B, 0x6B, 0x63, 0x63, 0x00, 0x00 };
		d['n'] = new byte[] { 0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00 };
		d['o'] = new byte[] { 0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00 };
		d['p'] = new byte[] { 0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00 };
		d['q'] = new byte[] { 0x00, 0x00, 0x00, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x06, 0x00 };
		d['r'] = new byte[] { 0x00, 0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00 };
		d['s'] = new byte[] { 0x00, 0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x06, 0x66, 0x3C, 0x00, 0x00 };
		d['t'] = new byte[] { 0x00, 0x30, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00 };
		d['u'] = new byte[] { 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00 };
		d['v'] = new byte[] { 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x3C, 0x18, 0x00, 0x00 };
		d['w'] = new byte[] { 0x00, 0x00, 0x00, 0x63, 0x63, 0x6B, 0x6B, 0x7F, 0x36, 0x36, 0x00, 0x00 };
		d['x'] = new byte[] { 0x00, 0x00, 0x00, 0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00, 0x00 };
		d['y'] = new byte[] { 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00 };
		d['z'] = new byte[] { 0x00, 0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x7E, 0x00, 0x00 };

		// Numbers
		d['0'] = new byte[] { 0x00, 0x3C, 0x66, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00 };
		d['1'] = new byte[] { 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00 };
		d['2'] = new byte[] { 0x00, 0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x7E, 0x00, 0x00 };
		d['3'] = new byte[] { 0x00, 0x3C, 0x66, 0x06, 0x1C, 0x06, 0x06, 0x06, 0x66, 0x3C, 0x00, 0x00 };
		d['4'] = new byte[] { 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0x6C, 0x7E, 0x0C, 0x0C, 0x0C, 0x00, 0x00 };
		d['5'] = new byte[] { 0x00, 0x7E, 0x60, 0x60, 0x7C, 0x06, 0x06, 0x06, 0x66, 0x3C, 0x00, 0x00 };
		d['6'] = new byte[] { 0x00, 0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00 };
		d['7'] = new byte[] { 0x00, 0x7E, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00 };
		d['8'] = new byte[] { 0x00, 0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00 };
		d['9'] = new byte[] { 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x66, 0x3C, 0x00, 0x00 };

		// Punctuation and symbols
		d[' '] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
		d['.'] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00 };
		d[','] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x08, 0x10, 0x00 };
		d[':'] = new byte[] { 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00 };
		d[';'] = new byte[] { 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x08, 0x10, 0x00 };
		d['!'] = new byte[] { 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00 };
		d['?'] = new byte[] { 0x00, 0x3C, 0x66, 0x06, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00 };
		d['-'] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
		d['_'] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00 };
		d['+'] = new byte[] { 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00 };
		d['='] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00 };
		d['*'] = new byte[] { 0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00 };
		d['/'] = new byte[] { 0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00 };
		d['\\'] = new byte[] { 0x00, 0x80, 0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00 };
		d['('] = new byte[] { 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00 };
		d[')'] = new byte[] { 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00 };
		d['['] = new byte[] { 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00 };
		d[']'] = new byte[] { 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00 };
		d['{'] = new byte[] { 0x00, 0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00 };
		d['}'] = new byte[] { 0x00, 0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00 };
		d['<'] = new byte[] { 0x00, 0x00, 0x06, 0x1C, 0x70, 0x70, 0x1C, 0x06, 0x00, 0x00, 0x00, 0x00 };
		d['>'] = new byte[] { 0x00, 0x00, 0x60, 0x38, 0x0E, 0x0E, 0x38, 0x60, 0x00, 0x00, 0x00, 0x00 };
		d['\''] = new byte[] { 0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
		d['"'] = new byte[] { 0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
		d['`'] = new byte[] { 0x00, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
		d['~'] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
		d['@'] = new byte[] { 0x00, 0x3C, 0x66, 0x6E, 0x6E, 0x6E, 0x60, 0x60, 0x66, 0x3C, 0x00, 0x00 };
		d['#'] = new byte[] { 0x00, 0x00, 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00, 0x00, 0x00 };
		d['$'] = new byte[] { 0x00, 0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x18, 0x00, 0x00, 0x00 };
		d['%'] = new byte[] { 0x00, 0x00, 0x62, 0x66, 0x0C, 0x18, 0x30, 0x66, 0x46, 0x00, 0x00, 0x00 };
		d['&'] = new byte[] { 0x00, 0x38, 0x6C, 0x38, 0x30, 0x7A, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00 };
		d['^'] = new byte[] { 0x00, 0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
		d['|'] = new byte[] { 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00 };

		return d;
	}

	protected override void ClearMeshData()
	{
	}
}
